module fsm_matriz8x8 (
    input clk,                // Reloj del sistema
    input reset,              // Señal de reset
    input [1:0] state,        // Datos de entrada para enviar
    output mosi,              // Master Out Slave In
    output sclk,              // Reloj SPI
    output cs                 // Chip Select
);

reg [7:0] data_in;
wire [7:0] data_out;

reg start;
wire busy;
wire avail;

wire [25:0] div_factor = 25000000;  // Factor de división fijo

spi_master spi (
    .clk(clk),
    .reset(~reset),
    .data_in(data_in),
    .start(start),
    .div_factor(div_factor),
    .mosi(mosi),
    .sclk(sclk),
    .cs(cs),
    .data_out(data_out),
    .busy(busy),
    .avail(avail)
);

reg [7:0] memory4CommandSend [0:30];
reg [5:0] mem_index = 0;
reg sendByte;
reg [10:0] state_send = 0;
reg [1:0] c2 = 0;

reg [31:0] contador = 0;
reg [7:0] letra_C [0:7];
reg [7:0] letra_O [0:7];
reg [7:0] letra_actual;

initial begin
    // Inicializar letra "C"
    letra_C[0] = 8'h7E;
    letra_C[1] = 8'h40;
    letra_C[2] = 8'h40;
    letra_C[3] = 8'h40;
    letra_C[4] = 8'h40;
    letra_C[5] = 8'h40;
    letra_C[6] = 8'h7E;
    letra_C[7] = 8'h00;

    // Inicializar letra "O"
    letra_O[0] = 8'h7E;
    letra_O[1] = 8'h41;
    letra_O[2] = 8'h41;
    letra_O[3] = 8'h41;
    letra_O[4] = 8'h41;
    letra_O[5] = 8'h41;
    letra_O[6] = 8'h7E;
    letra_O[7] = 8'h00;

    // Inicializar valores iniciales en memory4CommandSend
    memory4CommandSend[0] = 8'h0C;  // Shutdown command
    memory4CommandSend[1] = 8'h01;  // Shutdown Normal Operation
    memory4CommandSend[2] = 8'h09;  // Decode-Mode
    memory4CommandSend[3] = 8'h00;  // Decode-Mode No decode for digits 7–0
    memory4CommandSend[4] = 8'h0A;  // Intensity
    memory4CommandSend[5] = 8'h0A;  // Intensity value
    memory4CommandSend[6] = 8'h0B;  // Scan Limit
    memory4CommandSend[7] = 8'h07;  // Scan Limit Value
    memory4CommandSend[8] = 8'h0F;  // Display Test 
    memory4CommandSend[9] = 8'h00;  // Display Test Value
    
    // Inicializar letra actual
    letra_actual = letra_C;
end

always @(posedge clk) begin
    if (~reset) begin
        state_send <= 0;
        sendByte <= 0;
        mem_index <= 0;
        contador <= 0;
    end else begin
        case (state_send)
            0: begin
                data_in <= memory4CommandSend[mem_index]; 
                sendByte <= 1; 
                state_send <= 1;
            end
            1: begin
                state_send <= 2;
            end
            2: begin
                sendByte <= 0; 
                if (avail) begin
                    state_send <= 0;    
                    mem_index <= mem_index + 1;
                    if (mem_index > 25) begin
                        mem_index <= 10;    
                        state_send <= 3;    
                    end
                end
            end
            3: begin 
                mem_index <= 0;            
            end 
        endcase
    end
    
    // Contador para alternar letras
    contador <= contador + 1;
    if (contador == 50000000) begin  // Ajustar según la frecuencia de reloj y el tiempo deseado
        contador <= 0;
        if (letra_actual == letra_C) begin
            letra_actual <= letra_O;
        end else begin
            letra_actual <= letra_C;
        end
        
        // Actualizar memory4CommandSend con la nueva letra
        memory4CommandSend[10] = 8'h01;
        memory4CommandSend[11] = letra_actual[0];
        memory4CommandSend[12] = 8'h02;
        memory4CommandSend[13] = letra_actual[1];
        memory4CommandSend[14] = 8'h03;
        memory4CommandSend[15] = letra_actual[2];
        memory4CommandSend[16] = 8'h04;
        memory4CommandSend[17] = letra_actual[3];
        memory4CommandSend[18] = 8'h05;
        memory4CommandSend[19] = letra_actual[4];
        memory4CommandSend[20] = 8'h06;
        memory4CommandSend[21] = letra_actual[5];
        memory4CommandSend[22] = 8'h07;
        memory4CommandSend[23] = letra_actual[6];
        memory4CommandSend[24] = 8'h08;
        memory4CommandSend[25] = letra_actual[7];
    end
end

// Para enviar un byte por SPI
always @(negedge clk) begin
    if (~reset) begin
        start <= 0;
    end else begin
        case(start)
            0: begin  // IDLE
                if (!busy && sendByte) begin
                    start <= 1;
                end
            end
            1: begin  // SEND
                if (avail) begin
                    start <= 0;
                end
            end
        endcase
    end
end
endmodule
